{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Docs \u00b6 Welcome to the k8s@home docs!","title":"Home"},{"location":"#docs","text":"Welcome to the k8s@home docs!","title":"Docs"},{"location":"our-container-images/configuration/","text":"Configuration \u00b6 The following configuration is available across all the k8s@home container images. Environment Variables \u00b6 Name Default Description UMASK 0002 Set the default creation permission mode of files WAIT_FOR_VPN false EXTRA_ARGS Additional arguments to pass to the application TZ UTC Timezone (e.g. America/New_York ) Volumes \u00b6 Path Description /app Application install directory /config Application configuration directory","title":"Configuration"},{"location":"our-container-images/configuration/#configuration","text":"The following configuration is available across all the k8s@home container images.","title":"Configuration"},{"location":"our-container-images/configuration/#environment-variables","text":"Name Default Description UMASK 0002 Set the default creation permission mode of files WAIT_FOR_VPN false EXTRA_ARGS Additional arguments to pass to the application TZ UTC Timezone (e.g. America/New_York )","title":"Environment Variables"},{"location":"our-container-images/configuration/#volumes","text":"Path Description /app Application install directory /config Application configuration directory","title":"Volumes"},{"location":"our-container-images/deprecations/","text":"Deprecations \u00b6 Container images that were once here but now are gone it is likely that the application... developers are supporting their own images and conforming to Semantic Versioning , or has been replaced with a different application, or maintenance cost it too high to continue to build images for, or is no longer maintained","title":"Deprecations"},{"location":"our-container-images/deprecations/#deprecations","text":"Container images that were once here but now are gone it is likely that the application... developers are supporting their own images and conforming to Semantic Versioning , or has been replaced with a different application, or maintenance cost it too high to continue to build images for, or is no longer maintained","title":"Deprecations"},{"location":"our-container-images/getting-started/","text":"Getting started \u00b6 Running applications in Kubernetes is a bit different that in a regular Docker Swarm or Docker Compose setup. Our container images are tailored for running in Kubernetes. Purpose \u00b6 The goal of this project and the container images are to support Semantic Versioning and multiple architectures. We try to keep a KISS principle when building these images, which means no s6-overlay and all images are built on top of ubuntu:focal .","title":"Getting started"},{"location":"our-container-images/getting-started/#getting-started","text":"Running applications in Kubernetes is a bit different that in a regular Docker Swarm or Docker Compose setup. Our container images are tailored for running in Kubernetes.","title":"Getting started"},{"location":"our-container-images/getting-started/#purpose","text":"The goal of this project and the container images are to support Semantic Versioning and multiple architectures. We try to keep a KISS principle when building these images, which means no s6-overlay and all images are built on top of ubuntu:focal .","title":"Purpose"},{"location":"our-container-images/permissions/","text":"Permissions \u00b6 With Kubernetes, s6-overlay is not needed. Instead Kubernetes can use Security Context on either the pod or container to tell what the container should run as, and/or what permissions files should be written as. Managing Permissions \u00b6 There are several different methods you can use to make these containers have write access to your file storage. Note Our images use a default user/group id of 568 . The user and group ids cannot be changed at the container runtime. Security Contexts method \u00b6 You can change the Kubernetes Security Contexts to allow the container to have permissions to write to your file storage. In our Helm charts this can be accomplished by setting the podSecurityContext.runAsUser , podSecurityContext.runAsGroup , and podSecurityContext.fsGroup values to your required user / group ids. Direct volume method \u00b6 If you can access the volume's data without the pod running. You can run chown -R 568:568 <path-to-your-volume> . This step can be a bit complicated if you are not very familiar with your storage interface. initContainer method \u00b6 Implement a initContainer that runs as root to automatically chown the volume's data. Take the following as an example. initContainers : - name : update-volume-permission image : busybox command : [ \"sh\" , \"-c\" , \"chown -R 568:568 /mytest\" ] volumeMounts : - name : config mountPath : /config securityContext : runAsUser : 0","title":"Permissions"},{"location":"our-container-images/permissions/#permissions","text":"With Kubernetes, s6-overlay is not needed. Instead Kubernetes can use Security Context on either the pod or container to tell what the container should run as, and/or what permissions files should be written as.","title":"Permissions"},{"location":"our-container-images/permissions/#managing-permissions","text":"There are several different methods you can use to make these containers have write access to your file storage. Note Our images use a default user/group id of 568 . The user and group ids cannot be changed at the container runtime.","title":"Managing Permissions"},{"location":"our-container-images/permissions/#security-contexts-method","text":"You can change the Kubernetes Security Contexts to allow the container to have permissions to write to your file storage. In our Helm charts this can be accomplished by setting the podSecurityContext.runAsUser , podSecurityContext.runAsGroup , and podSecurityContext.fsGroup values to your required user / group ids.","title":"Security Contexts method"},{"location":"our-container-images/permissions/#direct-volume-method","text":"If you can access the volume's data without the pod running. You can run chown -R 568:568 <path-to-your-volume> . This step can be a bit complicated if you are not very familiar with your storage interface.","title":"Direct volume method"},{"location":"our-container-images/permissions/#initcontainer-method","text":"Implement a initContainer that runs as root to automatically chown the volume's data. Take the following as an example. initContainers : - name : update-volume-permission image : busybox command : [ \"sh\" , \"-c\" , \"chown -R 568:568 /mytest\" ] volumeMounts : - name : config mountPath : /config securityContext : runAsUser : 0","title":"initContainer method"},{"location":"our-helm-charts/getting-started/","text":"Getting started \u00b6 Helm must be installed to use our charts. Refer to Helm's documentation to get started. Installation \u00b6 helm repo add k8s-at-home https://k8s-at-home.com/charts/ You can then run helm search repo k8s-at-home to see the charts. Charts \u00b6 See Artifact Hub for a complete list.","title":"Getting started"},{"location":"our-helm-charts/getting-started/#getting-started","text":"Helm must be installed to use our charts. Refer to Helm's documentation to get started.","title":"Getting started"},{"location":"our-helm-charts/getting-started/#installation","text":"helm repo add k8s-at-home https://k8s-at-home.com/charts/ You can then run helm search repo k8s-at-home to see the charts.","title":"Installation"},{"location":"our-helm-charts/getting-started/#charts","text":"See Artifact Hub for a complete list.","title":"Charts"},{"location":"our-helm-charts/common-library/add-ons/","text":"Add-ons \u00b6 Our Helm charts have a few add-ons which are meant to simplify some features you might be looking for. These are sidecars that run in the same pod as your application you configured it with. Code Server \u00b6 The code-server add-on can be used to access and modify persistent volume data in your application. This can be useful when you need to edit the persistent volume data, for example with Home Assistant. Example values \u00b6 Below is a snippet from a values.yaml using the add-on. More configuration options can be found in our common chart documentation. Note This example will mount /config into the code-server sidecar. addons : codeserver : enabled : true image : repository : codercom/code-server tag : 3.9.0 workingDir : \"/config\" args : - --auth - \"none\" - --user-data-dir - \"/config/.vscode\" - --extensions-dir - \"/config/.vscode\" ingress : enabled : true annotations : kubernetes.io/ingress.class : \"nginx\" hosts : - host : app-config.domain.tld paths : - path : / pathType : Prefix tls : - hosts : - app-config.domain.tld volumeMounts : - name : config mountPath : /config Wireguard VPN \u00b6 The Wireguard add-on enables you to force all (or selected) network traffic through a VPN. This example shows how to add a Wireguard sidecar to our qBittorrent Helm chart . It does not cover all of the configuration possibilities of the Wireguard client image , but should give a good starting point for configuring a similar setup. Example values \u00b6 Below is an annotated example values.yaml that will result in a qBittorrent container with all its traffic routed through a VPN. In order to have functioning ingress and/or probes, it might be required to open certain networks or ports on the VPN firewall. That is beyond the scope of this document. Please refer to the Wireguard client image for more details on these environment variables. Note The WAIT_FOR_VPN environment variable is specifically implemented by our own qBittorrent image, and it will not work with other container images. image : repository : k8sathome/qbittorrent tag : v4.3.3 pullPolicy : IfNotPresent env : # Our qBittorrent image has a feature that can wait for the VPN to be connected before actually starting the application. # It does this by checking the contents of a file /shared/vpnstatus to contain the string 'connected'. WAIT_FOR_VPN : \"true\" persistence : config : enabled : true emptyDir : true mountPath : /config # This should be enabled so that both the qBittorrent and Wireguard container have access to a shared volume mounted to /shared. # It will be used to communicate between the two containers. shared : enabled : true emptyDir : true mountPath : /shared addons : vpn : enabled : true # This Should be set to `wireguard`. This will set the add-on to use the default settings for Wireguard based connections. type : wireguard # If the podSecurityContext is set to run as a different user, make sure to run the Wireguard container as UID/GID 568. # This is required for it to be able to read certain configuration files. securityContext : runAsUser : 568 runAsGroup : 568 env : # Enable a killswitch that kills all trafic when the VPN is not connected KILLSWITCH : \"true\" # The wireguard configuration file provided by your VPN provider goes here. # # Set AllowedIPs to 0.0.0.0/0 to route all traffic through the VPN. # # Pay close attention to the PostUp and PreDown lines. They must be added if you wish to run a script when the connection # is opened / closed. configFile : |- [Interface] PrivateKey = <my-private-key> Address = <interface address> DNS = <interface DNS server> PostUp = /config/up.sh %i PreDown = /config/down.sh %i [Peer] PublicKey = <my-public-key> AllowedIPs = 0.0.0.0/0 Endpoint = <peer endpoint> # The scripts that get run when the VPN connection opens/closes are defined here. # The default scripts will write a string to represent the current connection state to a file. # Our qBittorrent image has a feature that can wait for this file to contain the word 'connected' before actually starting the application. scripts : up : |- #!/bin/bash echo \"connected\" > /shared/vpnstatus down : |- #!/bin/bash echo \"disconnected\" > /shared/vpnstatus OpenVPN \u00b6 Similar to the Wireguard VPN, the OpenVPN add-on enables you to force all (or selected) network traffic through a VPN. This example shows how to add an OpenVPN sidecar to our qBittorrent Helm chart . It does not cover all of the configuration possibilities of the OpenVPN client image by @dperson , but should give a good starting point for configuring a similar setup. Example values \u00b6 Below is an annotated example values.yaml that will result in a qBittorrent container with all its traffic routed through a VPN. In order to have functioning ingress and/or probes, it might be required to open certain networks or ports on the VPN firewall. That is beyond the scope of this document. Please refer to the OpenVPN client image for more details on these environment variables. Note The WAIT_FOR_VPN environment variable is specifically implemented by our own qBittorrent image, and it will not work with other container images. image : repository : k8sathome/qbittorrent tag : v4.3.3 pullPolicy : IfNotPresent env : # Our qBittorrent image has a feature that can wait for the VPN to be connected before actually starting the application. # It does this by checking the contents of a file /shared/vpnstatus to contain the string 'connected'. WAIT_FOR_VPN : \"true\" persistence : config : enabled : true emptyDir : true mountPath : /config # This should be enabled so that both the qBittorrent and OpenVPN container have access to a shared volume mounted to /shared. # It will be used to communicate between the two containers. shared : enabled : true emptyDir : true mountPath : /shared addons : vpn : enabled : true # This Should be set to `openvpn`. This will set the add-on to use the default settings for OpenVPN based connections. type : openvpn openvpn : # This gets read by the Helm chart. The default OpenVPN image reads this and uses it to connect to the VPN provider. auth : | myuser mypassword # If the podSecurityContext is set to run as a different user, make sure to run the OpenVPN container as root. # This is required for it to be able to read certain configuration files. securityContext : runAsGroup : 0 runAsUser : 0 env : # Set this environment variable to 'on' to make sure all traffic gets routed through the VPN container. # Make sure to check the other environment variables for the OpenVPN image to see how you can exclude certain # traffic from these firewall rules. FIREWALL : 'on' # The .ovpn file provided by your VPN provider goes here. # # Any CA / certificate must either be placed inline, or provided through an additionalVolumeMount so that OpenVPN can find it. # # Pay close attention to the last 3 lines in this file. They must be added if you wish to run a script when the connection # is opened / closed. configFile : |- client dev tun proto udp remote my-awesome-vpn-provider.com 995 remote-cert-tls server resolv-retry infinite nobind tls-version-min 1.2 cipher AES-128-GCM compress ncp-disable tun-mtu-extra 32 auth-user-pass <ca> -----BEGIN CERTIFICATE----- MIIDMTCCAhmgAwIBAgIJAKnGGJK6qLqSMA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV -----END CERTIFICATE----- </ca> script-security 2 up /vpn/up.sh down /vpn/down.sh # The scripts that get run when the VPN connection opens/closes are defined here. # The default scripts will write a string to represent the current connection state to a file. # Our qBittorrent image has a feature that can wait for this file to contain the word 'connected' before actually starting the application. scripts : up : |- #!/bin/bash /etc/openvpn/up.sh echo \"connected\" > /shared/vpnstatus down : |- #!/bin/bash /etc/openvpn/down.sh echo \"disconnected\" > /shared/vpnstatus","title":"Add-ons"},{"location":"our-helm-charts/common-library/add-ons/#add-ons","text":"Our Helm charts have a few add-ons which are meant to simplify some features you might be looking for. These are sidecars that run in the same pod as your application you configured it with.","title":"Add-ons"},{"location":"our-helm-charts/common-library/add-ons/#code-server","text":"The code-server add-on can be used to access and modify persistent volume data in your application. This can be useful when you need to edit the persistent volume data, for example with Home Assistant.","title":"Code Server"},{"location":"our-helm-charts/common-library/add-ons/#example-values","text":"Below is a snippet from a values.yaml using the add-on. More configuration options can be found in our common chart documentation. Note This example will mount /config into the code-server sidecar. addons : codeserver : enabled : true image : repository : codercom/code-server tag : 3.9.0 workingDir : \"/config\" args : - --auth - \"none\" - --user-data-dir - \"/config/.vscode\" - --extensions-dir - \"/config/.vscode\" ingress : enabled : true annotations : kubernetes.io/ingress.class : \"nginx\" hosts : - host : app-config.domain.tld paths : - path : / pathType : Prefix tls : - hosts : - app-config.domain.tld volumeMounts : - name : config mountPath : /config","title":"Example values"},{"location":"our-helm-charts/common-library/add-ons/#wireguard-vpn","text":"The Wireguard add-on enables you to force all (or selected) network traffic through a VPN. This example shows how to add a Wireguard sidecar to our qBittorrent Helm chart . It does not cover all of the configuration possibilities of the Wireguard client image , but should give a good starting point for configuring a similar setup.","title":"Wireguard VPN"},{"location":"our-helm-charts/common-library/add-ons/#example-values_1","text":"Below is an annotated example values.yaml that will result in a qBittorrent container with all its traffic routed through a VPN. In order to have functioning ingress and/or probes, it might be required to open certain networks or ports on the VPN firewall. That is beyond the scope of this document. Please refer to the Wireguard client image for more details on these environment variables. Note The WAIT_FOR_VPN environment variable is specifically implemented by our own qBittorrent image, and it will not work with other container images. image : repository : k8sathome/qbittorrent tag : v4.3.3 pullPolicy : IfNotPresent env : # Our qBittorrent image has a feature that can wait for the VPN to be connected before actually starting the application. # It does this by checking the contents of a file /shared/vpnstatus to contain the string 'connected'. WAIT_FOR_VPN : \"true\" persistence : config : enabled : true emptyDir : true mountPath : /config # This should be enabled so that both the qBittorrent and Wireguard container have access to a shared volume mounted to /shared. # It will be used to communicate between the two containers. shared : enabled : true emptyDir : true mountPath : /shared addons : vpn : enabled : true # This Should be set to `wireguard`. This will set the add-on to use the default settings for Wireguard based connections. type : wireguard # If the podSecurityContext is set to run as a different user, make sure to run the Wireguard container as UID/GID 568. # This is required for it to be able to read certain configuration files. securityContext : runAsUser : 568 runAsGroup : 568 env : # Enable a killswitch that kills all trafic when the VPN is not connected KILLSWITCH : \"true\" # The wireguard configuration file provided by your VPN provider goes here. # # Set AllowedIPs to 0.0.0.0/0 to route all traffic through the VPN. # # Pay close attention to the PostUp and PreDown lines. They must be added if you wish to run a script when the connection # is opened / closed. configFile : |- [Interface] PrivateKey = <my-private-key> Address = <interface address> DNS = <interface DNS server> PostUp = /config/up.sh %i PreDown = /config/down.sh %i [Peer] PublicKey = <my-public-key> AllowedIPs = 0.0.0.0/0 Endpoint = <peer endpoint> # The scripts that get run when the VPN connection opens/closes are defined here. # The default scripts will write a string to represent the current connection state to a file. # Our qBittorrent image has a feature that can wait for this file to contain the word 'connected' before actually starting the application. scripts : up : |- #!/bin/bash echo \"connected\" > /shared/vpnstatus down : |- #!/bin/bash echo \"disconnected\" > /shared/vpnstatus","title":"Example values"},{"location":"our-helm-charts/common-library/add-ons/#openvpn","text":"Similar to the Wireguard VPN, the OpenVPN add-on enables you to force all (or selected) network traffic through a VPN. This example shows how to add an OpenVPN sidecar to our qBittorrent Helm chart . It does not cover all of the configuration possibilities of the OpenVPN client image by @dperson , but should give a good starting point for configuring a similar setup.","title":"OpenVPN"},{"location":"our-helm-charts/common-library/add-ons/#example-values_2","text":"Below is an annotated example values.yaml that will result in a qBittorrent container with all its traffic routed through a VPN. In order to have functioning ingress and/or probes, it might be required to open certain networks or ports on the VPN firewall. That is beyond the scope of this document. Please refer to the OpenVPN client image for more details on these environment variables. Note The WAIT_FOR_VPN environment variable is specifically implemented by our own qBittorrent image, and it will not work with other container images. image : repository : k8sathome/qbittorrent tag : v4.3.3 pullPolicy : IfNotPresent env : # Our qBittorrent image has a feature that can wait for the VPN to be connected before actually starting the application. # It does this by checking the contents of a file /shared/vpnstatus to contain the string 'connected'. WAIT_FOR_VPN : \"true\" persistence : config : enabled : true emptyDir : true mountPath : /config # This should be enabled so that both the qBittorrent and OpenVPN container have access to a shared volume mounted to /shared. # It will be used to communicate between the two containers. shared : enabled : true emptyDir : true mountPath : /shared addons : vpn : enabled : true # This Should be set to `openvpn`. This will set the add-on to use the default settings for OpenVPN based connections. type : openvpn openvpn : # This gets read by the Helm chart. The default OpenVPN image reads this and uses it to connect to the VPN provider. auth : | myuser mypassword # If the podSecurityContext is set to run as a different user, make sure to run the OpenVPN container as root. # This is required for it to be able to read certain configuration files. securityContext : runAsGroup : 0 runAsUser : 0 env : # Set this environment variable to 'on' to make sure all traffic gets routed through the VPN container. # Make sure to check the other environment variables for the OpenVPN image to see how you can exclude certain # traffic from these firewall rules. FIREWALL : 'on' # The .ovpn file provided by your VPN provider goes here. # # Any CA / certificate must either be placed inline, or provided through an additionalVolumeMount so that OpenVPN can find it. # # Pay close attention to the last 3 lines in this file. They must be added if you wish to run a script when the connection # is opened / closed. configFile : |- client dev tun proto udp remote my-awesome-vpn-provider.com 995 remote-cert-tls server resolv-retry infinite nobind tls-version-min 1.2 cipher AES-128-GCM compress ncp-disable tun-mtu-extra 32 auth-user-pass <ca> -----BEGIN CERTIFICATE----- MIIDMTCCAhmgAwIBAgIJAKnGGJK6qLqSMA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV -----END CERTIFICATE----- </ca> script-security 2 up /vpn/up.sh down /vpn/down.sh # The scripts that get run when the VPN connection opens/closes are defined here. # The default scripts will write a string to represent the current connection state to a file. # Our qBittorrent image has a feature that can wait for this file to contain the word 'connected' before actually starting the application. scripts : up : |- #!/bin/bash /etc/openvpn/up.sh echo \"connected\" > /shared/vpnstatus down : |- #!/bin/bash /etc/openvpn/down.sh echo \"disconnected\" > /shared/vpnstatus","title":"Example values"},{"location":"our-helm-charts/common-library/background/","text":"Background \u00b6 In Helm 3, their team introduced the concept of a Library chart . A library chart is a type of Helm chart that defines chart primitives or definitions which can be shared by Helm templates in other charts. This allows users to share snippets of code that can be re-used across charts, avoiding repetition and keeping charts DRY. The common library was created because we saw many charts requiring only a few select configuration options in their Helm charts. Let us for example take Sonarr , Sabnzbd , or Overseerr. Each of these charts only require setting service , port , persistence , ingress and image since state and app configuration is handled by the application itself. In order to stay somewhat DRY (Don't Repeat Yourself) and keeping with Helm 3 usage for a Library chart, we saw this pattern and decided it was worth it for us to create a library. This means each one of these app charts has a dependency on what we call the common library. The source code for our library chart can be found here .","title":"Background"},{"location":"our-helm-charts/common-library/background/#background","text":"In Helm 3, their team introduced the concept of a Library chart . A library chart is a type of Helm chart that defines chart primitives or definitions which can be shared by Helm templates in other charts. This allows users to share snippets of code that can be re-used across charts, avoiding repetition and keeping charts DRY. The common library was created because we saw many charts requiring only a few select configuration options in their Helm charts. Let us for example take Sonarr , Sabnzbd , or Overseerr. Each of these charts only require setting service , port , persistence , ingress and image since state and app configuration is handled by the application itself. In order to stay somewhat DRY (Don't Repeat Yourself) and keeping with Helm 3 usage for a Library chart, we saw this pattern and decided it was worth it for us to create a library. This means each one of these app charts has a dependency on what we call the common library. The source code for our library chart can be found here .","title":"Background"},{"location":"our-helm-charts/development/creating-a-new-chart/","text":"Creating a new chart \u00b6 Getting started \u00b6 To create a new chart, run the following: # Clone git clone cd charts sh -c \" $( curl --location https://taskfile.dev/install.sh ) \" -- -d -b .bin # Create chart PATH = $PATH : $PWD /.bin task deps:install task chart:create CHART = chart_name # Don't forgot edit some chart informations in charts/char_name/Chart.yaml and charts/char_name/values.yaml Second, be sure to checkout the many charts that already use this like qBittorrent , node-red or the many others in this repository. Include this chart as a dependency in your Chart.yaml e.g. # Chart.yaml ... dependencies : - name : common version : 3.0.1 # make sure to use the latest common library version available repository : https://k8s-at-home.com/charts/ ... Values \u00b6 Write a values.yaml with some basic defaults you want to present to the user e.g. # # IMPORTANT NOTE # # This chart inherits from our common library chart. You can check the default values/options here: # https://github.com/k8s-at-home/charts/tree/master/charts/common/values.yaml # image : repository : nodered/node-red pullPolicy : IfNotPresent tag : 1.2.5 strategy : type : Recreate # See more environment variables in the node-red documentation # https://nodered.org/docs/getting-started/docker env : {} # TZ: # NODE_OPTIONS: # NODE_RED_ENABLE_PROJECTS: # NODE_RED_ENABLE_SAFE_MODE: # FLOWS: service : port : port : 1880 ingress : enabled : false persistence : data : enabled : false emptyDir : false mountPath : /data If not using a service, set the service.enabled to false . ... service : enabled : false ... Templates \u00b6 Basic \u00b6 In its most basic form a new chart can consist of two simple files in the templates folder. This will automatically render everything, based only on what is (or isn't) present in values.yaml . templates/common.yaml : {{ include \"common.all . }} templates/NOTES.txt : {{ include \"common.notes.defaultNotes\" . }} Advanced \u00b6 Sometimes it is not required to implement additional logic in a chart that you do not wish to expose through settings in values.yaml . For example, when you want to always mount a Secret or configMap as a volume in the Pod. In that case it is also possible to write more advanced template files. templates/common.yaml : {{ /* First Make sure all variables are set and merged properly */ }} {{ - include \"common.values.setup\" . }} {{ /* Append a configMap to the additionalVolumes */ }} {{ - define \"myapp.configmap.volume\" - }} name : myapp-settings configMap : name : {{ template \"common.names.fullname\" . }} -settings {{ - end - }} {{ - $volume : = include \"myapp.configmap.volume\" . | fromYaml - }} {{ - if $volume - }} {{ - $additionalVolumes : = append .Values.additionalVolumes $volume }} {{ - $_ : = set .Values \"additionalVolumes\" (deepCopy $additionalVolumes) - }} {{ - end - }} {{ /* Render the templates */ }} {{ include \"common.all\" . }} An actual example of this can be found in the zigbee2mqtt chart. Testing \u00b6 If testing locally, make sure you update the dependencies with from the chart directory: helm dependency update If making local changes to the common library, the test chart may reference the local development chart: # common-test/Chart.yaml ... dependencies : - name : common version : <new version> repository : file://.../common ... Be sure to lint your chart to check for any errors. # Linting task chart:lint CHART = chart_name task chart:ct-lint CHART = chart_name","title":"Creating a new chart"},{"location":"our-helm-charts/development/creating-a-new-chart/#creating-a-new-chart","text":"","title":"Creating a new chart"},{"location":"our-helm-charts/development/creating-a-new-chart/#getting-started","text":"To create a new chart, run the following: # Clone git clone cd charts sh -c \" $( curl --location https://taskfile.dev/install.sh ) \" -- -d -b .bin # Create chart PATH = $PATH : $PWD /.bin task deps:install task chart:create CHART = chart_name # Don't forgot edit some chart informations in charts/char_name/Chart.yaml and charts/char_name/values.yaml Second, be sure to checkout the many charts that already use this like qBittorrent , node-red or the many others in this repository. Include this chart as a dependency in your Chart.yaml e.g. # Chart.yaml ... dependencies : - name : common version : 3.0.1 # make sure to use the latest common library version available repository : https://k8s-at-home.com/charts/ ...","title":"Getting started"},{"location":"our-helm-charts/development/creating-a-new-chart/#values","text":"Write a values.yaml with some basic defaults you want to present to the user e.g. # # IMPORTANT NOTE # # This chart inherits from our common library chart. You can check the default values/options here: # https://github.com/k8s-at-home/charts/tree/master/charts/common/values.yaml # image : repository : nodered/node-red pullPolicy : IfNotPresent tag : 1.2.5 strategy : type : Recreate # See more environment variables in the node-red documentation # https://nodered.org/docs/getting-started/docker env : {} # TZ: # NODE_OPTIONS: # NODE_RED_ENABLE_PROJECTS: # NODE_RED_ENABLE_SAFE_MODE: # FLOWS: service : port : port : 1880 ingress : enabled : false persistence : data : enabled : false emptyDir : false mountPath : /data If not using a service, set the service.enabled to false . ... service : enabled : false ...","title":"Values"},{"location":"our-helm-charts/development/creating-a-new-chart/#templates","text":"","title":"Templates"},{"location":"our-helm-charts/development/creating-a-new-chart/#basic","text":"In its most basic form a new chart can consist of two simple files in the templates folder. This will automatically render everything, based only on what is (or isn't) present in values.yaml . templates/common.yaml : {{ include \"common.all . }} templates/NOTES.txt : {{ include \"common.notes.defaultNotes\" . }}","title":"Basic"},{"location":"our-helm-charts/development/creating-a-new-chart/#advanced","text":"Sometimes it is not required to implement additional logic in a chart that you do not wish to expose through settings in values.yaml . For example, when you want to always mount a Secret or configMap as a volume in the Pod. In that case it is also possible to write more advanced template files. templates/common.yaml : {{ /* First Make sure all variables are set and merged properly */ }} {{ - include \"common.values.setup\" . }} {{ /* Append a configMap to the additionalVolumes */ }} {{ - define \"myapp.configmap.volume\" - }} name : myapp-settings configMap : name : {{ template \"common.names.fullname\" . }} -settings {{ - end - }} {{ - $volume : = include \"myapp.configmap.volume\" . | fromYaml - }} {{ - if $volume - }} {{ - $additionalVolumes : = append .Values.additionalVolumes $volume }} {{ - $_ : = set .Values \"additionalVolumes\" (deepCopy $additionalVolumes) - }} {{ - end - }} {{ /* Render the templates */ }} {{ include \"common.all\" . }} An actual example of this can be found in the zigbee2mqtt chart.","title":"Advanced"},{"location":"our-helm-charts/development/creating-a-new-chart/#testing","text":"If testing locally, make sure you update the dependencies with from the chart directory: helm dependency update If making local changes to the common library, the test chart may reference the local development chart: # common-test/Chart.yaml ... dependencies : - name : common version : <new version> repository : file://.../common ... Be sure to lint your chart to check for any errors. # Linting task chart:lint CHART = chart_name task chart:ct-lint CHART = chart_name","title":"Testing"},{"location":"our-helm-charts/development/dependencies/","text":"Dependencies \u00b6 If you would like to help create new charts using the common library, there's a few tools you will need. helm helm-docs task (optional)","title":"Dependencies"},{"location":"our-helm-charts/development/dependencies/#dependencies","text":"If you would like to help create new charts using the common library, there's a few tools you will need. helm helm-docs task (optional)","title":"Dependencies"},{"location":"our-helm-charts/development/unit-tests/","text":"Unit tests \u00b6 We unit test our common library, while it isn't near complete coverage but it does offer some basic checks. Running these tests can be done any way you like. In this document we describe a number of approaches. Directly on your development machine \u00b6 First set up the environment: export RUBYJQ_USE_SYSTEM_LIBRARIES = 1 bundle install Run the tests: bundle exec m -r test/charts Using Visual Studio Code \u00b6 Our repo comes with a Visual Studio Code development container definition and launch.json that allow you to quickly set up an environment in which you can run the tests. Prerequisites \u00b6 Visual Studio Code is installed. Docker is installed and running. The \"Remote - Containers\" extension is installed and enabled in Visual Studio Code. For more details, please refer to the official documentation . Running tests \u00b6 Once Visual Studio Code is set up, and you open the charts workspace, you will see a popup asking if you wish to re-open the workspace in a development container: Select the option that you prefer. The workspace will be reopened and a Dockerized workspace will be built. You can now use Visual Studio Code as normal. To run or debug the unit tests, click the \"Run\" button on the left sidebar and select the desired configuration: UnitTest - active spec file only : This configuration will try to run the currently opened test file. Note: Make sure that you have opened a valid test file ( .rb files in the test/charts folder), or this will not work. UnitTest - all spec files : This configuration will run the all test files in the test/charts folder. Next, press the green \"Play\" icon. This will start the tests show the outcome in a terminal window. Using a local Docker container \u00b6 The Visual Studio Code development container can also be leveraged without using Visual Studio Code. Prerequisites \u00b6 Docker is installed and running. You have the charts repo root folder opened in your shell of choice. The commands in this article assume you are running a Bash-compatible shell. Running tests \u00b6 The first step is to build the development container image containing the required tools. This step only needs to be done once. To build the container, run this command in your shell: docker build -t k8s-at-home/charts-unit-test -f .devcontainer/Dockerfile . When you wish to run the tests, run this command in your shell: docker run --rm -it -v $( pwd ) :/charts --entrypoint \"/bin/bash\" -w /charts k8s-at-home/charts-unit-test -l -c \"bundle exec m -r ./test/charts\" This will create a container with the charts repo root folder mounted to /charts and execute all the test files in the test/charts folder. Output \u00b6 A successful test will output something like the following... Started with run options --seed 52955 common-test::statefulset volumeClaimTemplates can set values for volumeClaimTemplates PASS (0.16s) volumeClaimTemplates should be empty by default PASS (0.06s) common-test::ports settings targetPort can be overridden PASS (0.17s) port name can be overridden PASS (0.17s) defaults to name \"http\" on port 8080 PASS (0.16s) targetPort cannot be a named port PASS (0.05s) common-test::pod replicas defaults to 1 PASS (0.08s) accepts integer as value PASS (0.08s) common-test::Environment settings Check no environment variables PASS (0.05s) set \"valueFrom\" environment variables PASS (0.11s) set \"static\" and \"Dynamic/Tpl\" environment variables PASS (0.15s) set \"Dynamic/Tpl\" environment variables PASS (0.11s) set \"static\" environment variables PASS (0.10s) common-test::ingress ingress with hosts PASS (0.10s) should be disabled when ingress.enabled: false PASS (0.06s) ingress with hosts template is evaluated PASS (0.11s) ingress with hosts and tls PASS (0.15s) ingress with hosts and tls templates is evaluated PASS (0.16s) should be enabled when ingress.enabled: true PASS (0.06s) common-test::controller type accepts \"daemonset\" PASS (0.06s) accepts \"statefulset\" PASS (0.06s) defaults to \"Deployment\" PASS (0.06s) Finished in 2.26077s 22 tests, 59 assertions, 0 failures, 0 errors, 0 skips","title":"Unit tests"},{"location":"our-helm-charts/development/unit-tests/#unit-tests","text":"We unit test our common library, while it isn't near complete coverage but it does offer some basic checks. Running these tests can be done any way you like. In this document we describe a number of approaches.","title":"Unit tests"},{"location":"our-helm-charts/development/unit-tests/#directly-on-your-development-machine","text":"First set up the environment: export RUBYJQ_USE_SYSTEM_LIBRARIES = 1 bundle install Run the tests: bundle exec m -r test/charts","title":"Directly on your development machine"},{"location":"our-helm-charts/development/unit-tests/#using-visual-studio-code","text":"Our repo comes with a Visual Studio Code development container definition and launch.json that allow you to quickly set up an environment in which you can run the tests.","title":"Using Visual Studio Code"},{"location":"our-helm-charts/development/unit-tests/#prerequisites","text":"Visual Studio Code is installed. Docker is installed and running. The \"Remote - Containers\" extension is installed and enabled in Visual Studio Code. For more details, please refer to the official documentation .","title":"Prerequisites"},{"location":"our-helm-charts/development/unit-tests/#running-tests","text":"Once Visual Studio Code is set up, and you open the charts workspace, you will see a popup asking if you wish to re-open the workspace in a development container: Select the option that you prefer. The workspace will be reopened and a Dockerized workspace will be built. You can now use Visual Studio Code as normal. To run or debug the unit tests, click the \"Run\" button on the left sidebar and select the desired configuration: UnitTest - active spec file only : This configuration will try to run the currently opened test file. Note: Make sure that you have opened a valid test file ( .rb files in the test/charts folder), or this will not work. UnitTest - all spec files : This configuration will run the all test files in the test/charts folder. Next, press the green \"Play\" icon. This will start the tests show the outcome in a terminal window.","title":"Running tests"},{"location":"our-helm-charts/development/unit-tests/#using-a-local-docker-container","text":"The Visual Studio Code development container can also be leveraged without using Visual Studio Code.","title":"Using a local Docker container"},{"location":"our-helm-charts/development/unit-tests/#prerequisites_1","text":"Docker is installed and running. You have the charts repo root folder opened in your shell of choice. The commands in this article assume you are running a Bash-compatible shell.","title":"Prerequisites"},{"location":"our-helm-charts/development/unit-tests/#running-tests_1","text":"The first step is to build the development container image containing the required tools. This step only needs to be done once. To build the container, run this command in your shell: docker build -t k8s-at-home/charts-unit-test -f .devcontainer/Dockerfile . When you wish to run the tests, run this command in your shell: docker run --rm -it -v $( pwd ) :/charts --entrypoint \"/bin/bash\" -w /charts k8s-at-home/charts-unit-test -l -c \"bundle exec m -r ./test/charts\" This will create a container with the charts repo root folder mounted to /charts and execute all the test files in the test/charts folder.","title":"Running tests"},{"location":"our-helm-charts/development/unit-tests/#output","text":"A successful test will output something like the following... Started with run options --seed 52955 common-test::statefulset volumeClaimTemplates can set values for volumeClaimTemplates PASS (0.16s) volumeClaimTemplates should be empty by default PASS (0.06s) common-test::ports settings targetPort can be overridden PASS (0.17s) port name can be overridden PASS (0.17s) defaults to name \"http\" on port 8080 PASS (0.16s) targetPort cannot be a named port PASS (0.05s) common-test::pod replicas defaults to 1 PASS (0.08s) accepts integer as value PASS (0.08s) common-test::Environment settings Check no environment variables PASS (0.05s) set \"valueFrom\" environment variables PASS (0.11s) set \"static\" and \"Dynamic/Tpl\" environment variables PASS (0.15s) set \"Dynamic/Tpl\" environment variables PASS (0.11s) set \"static\" environment variables PASS (0.10s) common-test::ingress ingress with hosts PASS (0.10s) should be disabled when ingress.enabled: false PASS (0.06s) ingress with hosts template is evaluated PASS (0.11s) ingress with hosts and tls PASS (0.15s) ingress with hosts and tls templates is evaluated PASS (0.16s) should be enabled when ingress.enabled: true PASS (0.06s) common-test::controller type accepts \"daemonset\" PASS (0.06s) accepts \"statefulset\" PASS (0.06s) defaults to \"Deployment\" PASS (0.06s) Finished in 2.26077s 22 tests, 59 assertions, 0 failures, 0 errors, 0 skips","title":"Output"}]}